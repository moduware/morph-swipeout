<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>morph-swipeout test</title>

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>

    <link rel="import" href="../morph-swipeout.html">
    <link rel="import" href="../../polymer/lib/mixins/gesture-event-listeners.html">
    <link rel="import" href="../../morph-shared-colors/morph-shared-colors.html">
    <link rel="import" href="../../morph-button/morph-button.html">
  </head>
  <body>

    <!-- TODO: update fixture markup to include swiper-integration-class to morph-button class -->
    <!-- TODO: create fixture for swipeout-delete property for IOS -->
    <!-- TODO: create fixture for swipeout-delete property for Android -->
    <!-- TODO: create fixture for item-delete property for IOS -->
    <!-- TODO: create fixture for item-delete property for IOS -->
    <!-- TODO: create fixture for swipeout-prompt-text property for IOS -->
    <!-- TODO: create fixture for swipeout-prompt-text property for Android -->

    <test-fixture id="BasicIosTestFixture">
      <template>
        <morph-swipeout platform="ios">
          <span slot="left-buttons">
            <morph-button class="swiper-integration-class" platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="BasicAndroidTestFixture">
      <template>
        <morph-swipeout platform="android">
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="android" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureOverswiper">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="AndroidTestFixtureOverswiper">
      <template>
        <morph-swipeout platform="android" overswiper>
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="android" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureSwipeoutDelete">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat swipeout-delete>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <script>
      describe('morph-swipeout', () => {

        describe('_getMorphButtonElement()', () => {
          let iosElement;

          beforeEach( function() {
            iosElement = fixture('BasicIosTestFixture');
          });

          it('Should return the correct button from left', async () => {
            const buttonPosition = 'left';
            const leftMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedInnerHTMLOfMorphButton = 'Action';
            
            expect(leftMorphButton.innerHTML).to.equal(expectedInnerHTMLOfMorphButton);
          });

          it('Should return the correct button from right', async () => {
            const buttonPosition = 'right';
            const rightMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedInnerHTMLOfMorphButton = 'Delete';

            expect(rightMorphButton.innerHTML).to.equal(expectedInnerHTMLOfMorphButton);
          });

          it('Should return the correct color attribute of left morph-button', async () => {
            const buttonPosition = 'left';
            const leftMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedColorAttributeOfMorphButton = 'green';
            
            expect(leftMorphButton.color).to.be.equal(expectedColorAttributeOfMorphButton);
          });

          it('Should return the correct color attribute of right morph-button', async () => {
            const buttonPosition = 'right';
            const rightMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedColorAttributeOfMorphButton = 'red';

            expect(rightMorphButton.color).to.be.equal(expectedColorAttributeOfMorphButton);
          });



        }); // _getMorphButtonElement()

        describe('_getElementBackgroundColor(element) for IOS platform', () => {
          let element;

          beforeEach(function () {
            element = fixture('BasicIosTestFixture');
          });

          it('Should return the correct background-color for left morph-button', async () => {
            const leftMorphButton = await element._getMorphButtonElement('left');
            const result = element._getElementBackgroundColor(leftMorphButton);
            const styles = window.getComputedStyle(leftMorphButton);
            const expectedBackgroundColor = 'rgb(76, 217, 100)';

            expect(result).to.equal(expectedBackgroundColor);
          });

          it('Should return the correct background-color for right morph-button', async () => {
            const rightMorphButton = await element._getMorphButtonElement('right');
            const result = element._getElementBackgroundColor(rightMorphButton);
            const expectedBackgroundColor = 'rgb(255, 59, 48)';

            expect(result).to.equal(expectedBackgroundColor);
          });

        }); // _getElementBackgroundColor(element) for IOS platform

        // BasicAndroidTestFixture
        describe('_getElementBackgroundColor(buttonPosition) for Android platform', () => {
          let element;

          beforeEach(function () {
            element = fixture('BasicAndroidTestFixture');
          });

          it('Should return the correct background-color for left morph-button', async () => {
            const rightMorphButton = await element._getMorphButtonElement('left');
            const result = element._getElementBackgroundColor(rightMorphButton);
            const expectedBackgroundColor = 'rgb(76, 175, 80)';

            expect(result).to.equal(expectedBackgroundColor);
          });

        }); // _getElementBackgroundColor(buttonPosition) for Android platform
        

        // TODO: FIX TEST FROM THIS LINE ONWARDS
        describe('handleTrack(event) for iOS', () => {
          let element, functionStub;
          let mockEvent;

          beforeEach( () => {
            element = fixture('BasicIosTestFixture');

            stub('morph-swipeout', {
              handleTrack: function () {
                console.log('handleTrack called!');
              }
            });
          });

          it('Should call handleTrack when track event is fired', (done) => {

            flush(function() {
              expect(element.handleTrack.callCount).to.be.equal(0);

              Polymer.Gestures.addListener(element, 'track', e => {
                expect(element.handleTrack.callCount).to.be.equal(1);
                done();
              });

              var event = new CustomEvent('track', {
                detail: {dx: 200}
              });
              
              element.dispatchEvent(event);
            });
            
          });
          
          
        }); // handleTrack(event) for iOS
        
        describe('overswiper for IOS', () => {
          let element;

          beforeEach( () => {
            element = fixture('IosTestFixtureOverswiper');
          });

          describe('Track distance is greater than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {

              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: -601,
                  state: 'end'
                }
              });
            });

            afterEach(function () {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should call _completeOverswipe', (done) => {
              flush(function () {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._completeOverswipe.callCount).to.be.equal(1);
                  done();
                });
                
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);

              });

            });
            
            it('Should call _handleOverswipe', (done) => {
              flush(function () {
                Polymer.Gestures.addListener(element, 'track', e => {
                  flush(function() {
                    expect(element._handleOverswipe.callCount).to.be.equal(1);
                    done();
                  });

                });
                
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });

            });

          }); // Track distance is greater than overswipeTreshold

          describe('Track distance is less than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {

              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 201,
                  state: 'end'
                }
              });
            });

            afterEach( () => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should NOT call _completeOverswipe', (done) => {
              flush(function() {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._completeOverswipe.called).to.be.false;
                  done();
                });
    
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });
            });

            it('Should NOT call _handleOverswipe', (done) => {
              flush(function() {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._handleOverswipe.called).to.be.false;
                  done();
                });

                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });
            });

          }); // Track distance is less than overswipeTreshold


          
        }); // overswiper for IOS

        describe('overswiper for Android', () => {
          let element;

          beforeEach(() => {
            element = fixture('AndroidTestFixtureOverswiper');
          });

          describe('Track distance is greater than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {
              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 600,
                  state: 'end'
                }
              });
            });

            afterEach(() => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should call _completeOverswipe', (done) => {
              flush(function() {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._completeOverswipe.calledOnce).to.be.true;
                  done();
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });
            });

            it('Should call _handleOverswipe', (done) => {
              flush(function () {
                Polymer.Gestures.addListener(element, 'track', e => {
                  flush(() => {
                    expect(element._handleOverswipe.calledOnce).to.be.true;
                    done();
                  });
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });
            });

          });

          describe('Track distance is less than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {
              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 200,
                  state: 'end'
                }
              });
            });

            afterEach(() => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should NOT call _completeOverswipe', (done) => {
              flush(() => {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._completeOverswipe.calledOnce).to.be.false;
                  done();              
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });

            });

            it('Should NOT call _handleOverswipe', (done) => {
              flush(() => {
                Polymer.Gestures.addListener(element, 'track', e => {
                  flush(() => {
                    expect(element._handleOverswipe.calledOnce).to.be.false;
                    done();
                  });
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });
            });

          });
        }); // overswiper for Android

        // swipeout-delete
        describe('swipeout-delete property for IOS', () => {
          it('');
        }); // swipeout-delete property for IOS
        
        describe.skip('swipeout-delete property for Android', () => {

        }); // swipeout-delete property for Android
        
        describe.skip('item-delete property for IOS', () => {

        }); // item-delete property for IOS

        describe.skip('item-delete property for Android', () => {

        }); // item-delete property for IOS
        
        
        describe.skip('swipeout-prompt-text property for IOS', () => {
        
        }); // swipeout-prompt-text property for IOS
        
        describe.skip('swipeout-prompt-text property for Android', () => {

        }); // swipeout-prompt-text property for Android


      }); // morph-swipeout



    </script>

  </body>
</html>
