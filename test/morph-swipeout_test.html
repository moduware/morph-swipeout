<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>morph-swipeout test</title>

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/wct-browser-legacy/browser.js"></script>
    <script src="../node_modules/@polymer/iron-test-helpers/mock-interactions.js" type="module"></script>

    <script type="module" src="../node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js"></script>
    <script type="module" src="../node_modules/@moduware/morph-shared-colors/morph-shared-colors.js"></script>
    <script type="module" src="../node_modules/@moduware/morph-button/morph-button.js"></script>
    <script type="module" src="../morph-swipeout.js"></script>
  </head>

  <body>

    <test-fixture id="BasicIosTestFixture">
      <template>
        <morph-swipeout platform="ios">
          <span slot="left-buttons">
            <morph-button class="swiper-integration-class" platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="BasicAndroidTestFixture">
      <template>
        <morph-swipeout platform="android">
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="android" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureOverswiper">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="AndroidTestFixtureOverswiper">
      <template>
        <morph-swipeout platform="android" overswiper>
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="android" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureSwipeoutDelete">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button class="swiper-integration-class" platform="ios" color="red" filled big flat swipeout-delete>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="AndroidTestFixtureSwipeoutDelete">
      <template>
        <morph-swipeout platform="android" overswiper>
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button class="swiper-integration-class" platform="android" color="red" filled big flat swipeout-delete>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureItemDelete">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button class="swiper-integration-class" platform="ios" color="red" filled big flat item-delete>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="AndroidTestFixtureItemDelete">
      <template>
        <morph-swipeout platform="android" overswiper>
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button class="swiper-integration-class" platform="android" color="red" filled big flat item-delete>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureSwipeoutPromptText">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button class="swiper-integration-class" platform="ios" color="red" filled big flat swipeout-delete swipeout-prompt-text="Do you want to delete?">Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="AndroidTestFixtureSwipeoutPromptText">
      <template>
        <morph-swipeout platform="android" overswiper>
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button class="swiper-integration-class" platform="android" color="red" filled big flat swipeout-delete swipeout-prompt-text="Do you want to delete?">Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <script type="module">

      import '../morph-swipeout.js';
      import '@polymer/polymer/lib/mixins/gesture-event-listeners.js';
      import { addListener } from '@polymer/polymer/lib/utils/gestures.js';
      
      describe('morph-swipeout', () => {

        describe('_closeSwipe()', () => {
          let iosElement;

          beforeEach(function () {
            iosElement = fixture('BasicIosTestFixture');
          });

          it('Should return transform value "translateX(0px)"', async () => {
            await iosElement.updateComplete;

            const shadow = iosElement.shadowRoot;
            const rootContainer = shadow.querySelector('#rootContainer');
            let styles = window.getComputedStyle(rootContainer);
            // call _closeSwipe
            iosElement._closeSwipe();
            await iosElement.updateComplete;
            // check if it changed to correct transform value
            expect(rootContainer.style.transform).to.be.equal('translateX(0px)');
          });
        });

        //_calculateSwipeSlowDown

        describe('_calculateSwipeSlowDown()', () => {
          let iosElement;

          beforeEach(function () {
            iosElement = fixture('BasicIosTestFixture');
          });

          it('should return expected result when pass in 1 distance and 1 offset', async () => {
            await iosElement.updateComplete;
            const expected = 0.5;
            const result = iosElement._calculateSwipeSlowDown(1, 1);
            expect(result).to.be.equal(expected);
          });

          it('should return expected result when pass in 100 distance and 100 offset', async () => {
            await iosElement.updateComplete;
            const expected = 50;
            const result = iosElement._calculateSwipeSlowDown(100, 100);
            expect(result).to.be.equal(expected);
          });

          it('should accept an optional 3rd parameter and return expected result', async () => {
            await iosElement.updateComplete;
            const expected = 75;
            const result = iosElement._calculateSwipeSlowDown(100, 100, 4);
            expect(result).to.be.equal(expected);
          });
        });

        // _confirmDialog
        describe('_calculateSwipeSlowDown()', () => {
          let iosElement;

          beforeEach(function () {
            iosElement = fixture('BasicIosTestFixture');
          });
          
          it('should return true if window.confirm returns true', async () => {
            await iosElement.updateComplete;
            const confirmTrue = sinon.stub(window, "confirm", () => {return true});
            const confirmResult = await iosElement._confirmDialog('hello');
            
            expect(confirmResult).to.be.true;

            // restores the stub method window.confirm
            confirmTrue.restore();
          });
          
          it('should return false if window.confirm returns false', async () => {
            await iosElement.updateComplete;
            const confirmTrue = sinon.stub(window, "confirm", () => { return false });
            const confirmResult = await iosElement._confirmDialog('hello');
            
            expect(confirmResult).to.be.false;

            // restores the stub method window.confirm
            confirmTrue.restore();
          });
        });

        // _completeOverswipe
        describe('_completeOverswipe(direction)', () => {
          let iosElement;

          beforeEach(function () {
            iosElement = fixture('BasicIosTestFixture');
          });

          it('Should return positive value translateX() if "right" direction passed in', async () => {
            await iosElement.updateComplete;
            const shadow = iosElement.shadowRoot;
            const rootContainer = shadow.querySelector('#rootContainer');
            const expected = 'translateX(900px)';

            iosElement._completeOverswipe('right');
            const transformValue = rootContainer.style.transform;

            rootContainer.style.transform
            expect(transformValue).to.be.equal(expected);
          });

          it('Should return negative value translateX() if "left" direction passed in', async () => {
            await iosElement.updateComplete;
            const shadow = iosElement.shadowRoot;
            const rootContainer = shadow.querySelector('#rootContainer');
            const expected = 'translateX(-900px)';
            
            iosElement._completeOverswipe('left');
            const transformValue = rootContainer.style.transform;

            expect(transformValue).to.be.equal(expected);
          });
        });

        describe('_getMorphButtonElement()', () => {
          let iosElement;

          beforeEach( function() {
            iosElement = fixture('BasicIosTestFixture');
          });

          it('Should return the correct button from left', async () => {
            const buttonPosition = 'left';
            const leftMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedInnerHTMLOfMorphButton = 'Action';
            
            expect(leftMorphButton.innerHTML).to.equal(expectedInnerHTMLOfMorphButton);
          });

          it('Should return the correct button from right', async () => {
            const buttonPosition = 'right';
            const rightMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedInnerHTMLOfMorphButton = 'Delete';

            expect(rightMorphButton.innerHTML).to.equal(expectedInnerHTMLOfMorphButton);
          });

          it('Should return the correct color attribute of left morph-button', async () => {
            const buttonPosition = 'left';
            const leftMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedColorAttributeOfMorphButton = 'green';
            
            expect(leftMorphButton.color).to.be.equal(expectedColorAttributeOfMorphButton);
          });

          it('Should return the correct color attribute of right morph-button', async () => {
            const buttonPosition = 'right';
            const rightMorphButton = await iosElement._getMorphButtonElement(buttonPosition);
            const expectedColorAttributeOfMorphButton = 'red';

            expect(rightMorphButton.color).to.be.equal(expectedColorAttributeOfMorphButton);
          });



        }); // _getMorphButtonElement()

        describe('_getElementBackgroundColor(element) for IOS platform', () => {
          let element;

          beforeEach(function () {
            element = fixture('BasicIosTestFixture');
          });

          it('Should return the correct background-color for left morph-button', async () => {
            const leftMorphButton = await element._getMorphButtonElement('left');
            const result = element._getElementBackgroundColor(leftMorphButton);
            const styles = window.getComputedStyle(leftMorphButton);
            const expectedBackgroundColor = 'rgb(76, 217, 100)';

            expect(result).to.equal(expectedBackgroundColor);
          });

          it('Should return the correct background-color for right morph-button', async () => {
            const rightMorphButton = await element._getMorphButtonElement('right');
            const result = element._getElementBackgroundColor(rightMorphButton);
            const expectedBackgroundColor = 'rgb(255, 59, 48)';

            expect(result).to.equal(expectedBackgroundColor);
          });

        }); // _getElementBackgroundColor(element) for IOS platform

        // BasicAndroidTestFixture
        describe('_getElementBackgroundColor(buttonPosition) for Android platform', () => {
          let element;

          beforeEach(function () {
            element = fixture('BasicAndroidTestFixture');
          });

          it('Should return the correct background-color for left morph-button', async () => {
            const rightMorphButton = await element._getMorphButtonElement('left');
            const result = element._getElementBackgroundColor(rightMorphButton);
            const expectedBackgroundColor = 'rgb(76, 175, 80)';

            expect(result).to.equal(expectedBackgroundColor);
          });

        }); // _getElementBackgroundColor(buttonPosition) for Android platform
        

        // TODO: FIX TEST FROM THIS LINE ONWARDS
        describe('handleTrack(event) for iOS', () => {
          let element, functionStub;
          let mockEvent;

          beforeEach( () => {
            element = fixture('BasicIosTestFixture');

            stub('morph-swipeout', {
              handleTrack: function () {
                console.log('handleTrack called!');
              }
            });
          });

          afterEach(function () {
            element.handleTrack.restore();
          });

          it('Should call handleTrack when track event is fired', (done) => {
            flush(function() {
              expect(element.handleTrack.callCount).to.be.equal(0);
              
              addListener(element, 'track', e => {
                expect(element.handleTrack.callCount).to.be.equal(1);
                done();
              });

              var event = new CustomEvent('track', {
                detail: {dx: 200}
              });
              
              element.dispatchEvent(event);
            });
            
          });
          
          
        }); // handleTrack(event) for iOS
        
        describe('overswiper for IOS', () => {
          let element;

          beforeEach( () => {
            element = fixture('IosTestFixtureOverswiper');
          });

          describe('Track distance is greater than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {

              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: -601,
                  state: 'end'
                }
              });
            });

            afterEach(function () {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should call _completeOverswipe', (done) => {
              flush(function () {
                addListener(element, 'track', e => {
                  expect(element._completeOverswipe.callCount).to.be.equal(1);
                  done();
                });
                
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);

              });

            });
            
            it('Should call _handleOverswipe', (done) => {
              flush(function () {
                addListener(element, 'track', e => {
                  flush(function() {
                    expect(element._handleOverswipe.callCount).to.be.equal(1);
                    done();
                  });

                });
                
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });

            });

          }); // Track distance is greater than overswipeTreshold

          describe('Track distance is less than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {

              stub('morph-swipeout', {
                _completeOverswipe: function (left) {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 201,
                  state: 'end'
                }
              });
            });

            afterEach( () => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should NOT call _completeOverswipe', (done) => {
              flush(function() {
                addListener(element, 'track', e => {
                  expect(element._completeOverswipe.called).to.be.false;
                  done();
                });

                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });
            });

            it('Should NOT call _handleOverswipe', (done) => {
              flush(function() {
                addListener(element, 'track', e => {
                  expect(element._handleOverswipe.called).to.be.false;
                  done();
                });

                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });
            });

          }); // Track distance is less than overswipeTreshold


          
        }); // overswiper for IOS

        describe('overswiper for Android', () => {
          let element;

          beforeEach(() => {
            element = fixture('AndroidTestFixtureOverswiper');
          });

          describe('Track distance is greater than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {
              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 600,
                  state: 'end'
                }
              });
            });

            afterEach(() => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should call _completeOverswipe', (done) => {
              flush(function() {
                addListener(element, 'track', e => {
                  expect(element._completeOverswipe.calledOnce).to.be.true;
                  done();
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });
            });

            it('Should call _handleOverswipe', (done) => {
              flush(function () {
                addListener(element, 'track', e => {
                  flush(() => {
                    expect(element._handleOverswipe.calledOnce).to.be.true;
                    done();
                  });
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });
            });

          });

          describe('Track distance is less than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {
              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 200,
                  state: 'end'
                }
              });
            });

            afterEach(() => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should NOT call _completeOverswipe', (done) => {
              flush(() => {
                addListener(element, 'track', e => {
                  expect(element._completeOverswipe.calledOnce).to.be.false;
                  done();              
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });

            });

            it('Should NOT call _handleOverswipe', (done) => {
              flush(() => {
                addListener(element, 'track', e => {
                  flush(() => {
                    expect(element._handleOverswipe.calledOnce).to.be.false;
                    done();
                  });
                });

                element._trackInitialTransform = 0;
                element.dispatchEvent(endEvent);
              });
            });

          });
        }); // overswiper for Android

        // swipeout-delete
        describe('swipeout-delete property for IOS', () => {
          let element, buttonElement;

          beforeEach(async () => {
            element = fixture('IosTestFixtureSwipeoutDelete');
            buttonElement = await element._getMorphButtonElement('right');

            stub('morph-swipeout', {
              _getMorphButtonElement: async function () {
                return buttonElement;
              }
            });

            stub('morph-swipeout', {
              _animateDeleteAction: function () {
                console.log('_animateDeleteAction called!');
              }
            });

          });

          it('Should call _animateDeleteAction when swipeout-delete attribute is present on morph-button', async () => {
            await element._handleOverswipe();
            expect(element._animateDeleteAction.callCount).to.be.equal(1);
          });
        }); // swipeout-delete property for IOS


        describe('swipeout-delete property for Android', () => {
          
          let element, buttonElement;

          beforeEach(async () => {
            element = fixture('AndroidTestFixtureSwipeoutDelete');
            buttonElement = await element._getMorphButtonElement('right');

            stub('morph-swipeout', {
              _getMorphButtonElement: async function () {
                return buttonElement;
              }
            });

            stub('morph-swipeout', {
              _animateDeleteAction: function () {
                console.log('_animateDeleteAction called!');
              }
            });

          });

          it('Should call _animateDeleteAction when swipeout-delete attribute is present on morph-button', async () => {
            await element._handleOverswipe();
            expect(element._animateDeleteAction.callCount).to.be.equal(1);
          });
        }); // swipeout-delete property for Android
        
        describe('item-delete property for IOS', () => {
          let element, buttonElement;

          beforeEach(async () => {
            element = fixture('IosTestFixtureItemDelete');
            buttonElement = await element._getMorphButtonElement('right');

            stub('morph-swipeout', {
              _getMorphButtonElement: async function () {
                return buttonElement;
              }
            });

            stub('morph-swipeout', {
              _animateDeleteAction: function () {
                console.log('_animateDeleteAction called!');
              }
            });

          });

          it('Should call _animateDeleteAction when item-delete attribute is present on morph-button', async () => {
            await element._handleOverswipe();
            expect(element._animateDeleteAction.callCount).to.be.equal(1);
          });
        }); // item-delete property for IOS

        describe('item-delete property for Android', () => {
          AndroidTestFixtureItemDelete
          let element, buttonElement;

          beforeEach(async () => {
            element = fixture('AndroidTestFixtureItemDelete');
            buttonElement = await element._getMorphButtonElement('right');

            stub('morph-swipeout', {
              _getMorphButtonElement: async function () {
                return buttonElement;
              }
            });

            stub('morph-swipeout', {
              _animateDeleteAction: function () {
                console.log('_animateDeleteAction called!');
              }
            });

          });

          it('Should call _animateDeleteAction when item-delete attribute is present on morph-button', async () => {
            await element._handleOverswipe();
            expect(element._animateDeleteAction.callCount).to.be.equal(1);
          });
        }); // item-delete property for IOS
        
        
        describe('swipeout-prompt-text property for IOS', () => {
          let element, buttonElement;

          beforeEach(async () => {
            element = fixture('IosTestFixtureSwipeoutPromptText');

            buttonElement = await element._getMorphButtonElement('right');
            
            stub('morph-swipeout', {
              _confirmDialog: async function () {
                return true;
              }
            });

            stub('morph-swipeout', {
              _getMorphButtonElement: async function () {
                return buttonElement;
              }
            });

            stub('morph-swipeout', {
              _animateDeleteAction: function () {
                console.log('_animateDeleteAction called!');
              }
            });
          });

          it('Should have text', () => {
            expect(buttonElement.hasAttribute('swipeout-prompt-text')).to.be.true;
          });

          it('Should have text', () => {
            let promptTExt = buttonElement.getAttribute('swipeout-prompt-text');
            let expected = 'Do you want to delete?';

            expect(promptTExt).to.be.equal(expected);
          });

          it('Should call _animateDeleteAction when confirm is true and swipe-delete attribute is present on morph-button', async () => {
            await element._handleOverswipe();
            
            expect(element._animateDeleteAction.callCount).to.be.equal(1);
          });


        }); // swipeout-prompt-text property for IOS
        
        describe('swipeout-prompt-text property for Android', () => {
          let element, buttonElement;

          beforeEach(async () => {
            element = fixture('AndroidTestFixtureSwipeoutPromptText');

            buttonElement = await element._getMorphButtonElement('right');

            stub('morph-swipeout', {
              _confirmDialog: async function () {
                return true;
              }
            });

            stub('morph-swipeout', {
              _getMorphButtonElement: async function () {
                return buttonElement;
              }
            });

            stub('morph-swipeout', {
              _animateDeleteAction: function () {
                console.log('_animateDeleteAction called!');
              }
            });
          });

          it('Should have text', () => {
            expect(buttonElement.hasAttribute('swipeout-prompt-text')).to.be.true;
          });

          it('Should have text', () => {
            let promptTExt = buttonElement.getAttribute('swipeout-prompt-text');
            let expected = 'Do you want to delete?';

            expect(promptTExt).to.be.equal(expected);
          });

          it('Should call _animateDeleteAction when confirm is true and swipe-delete attribute is present on morph-button', async () => {
            await element._handleOverswipe();

            expect(element._animateDeleteAction.callCount).to.be.equal(1);
          });
        }); // swipeout-prompt-text property for Android


      }); // morph-swipeout

    </script>

  </body>
</html>
