<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>morph-swipeout test</title>

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>

    <link rel="import" href="../morph-swipeout.html">
    <link rel="import" href="../../polymer/lib/mixins/gesture-event-listeners.html">
    <link rel="import" href="../../morph-shared-colors/morph-shared-colors.html">
    <link rel="import" href="../../morph-button/morph-button.html">
  </head>
  <body>

    <test-fixture id="BasicIosTestFixture">
      <template>
        <morph-swipeout platform="ios">
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="BasicAndroidTestFixture">
      <template>
        <morph-swipeout platform="android">
          <span slot="left-buttons">
            <morph-button platform="android" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="android" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <test-fixture id="IosTestFixtureOverswiper">
      <template>
        <morph-swipeout platform="ios" overswiper>
          <span slot="left-buttons">
            <morph-button platform="ios" color="green" filled big flat>Action</morph-button>
          </span>
          Swipeout content
          <span slot="right-buttons">
            <morph-button platform="ios" color="red" filled big flat>Delete</morph-button>
          </span>
        </morph-swipeout>
      </template>
    </test-fixture>

    <script>
      describe('morph-swipeout', () => {

        describe('_getMorphButtonElement()', () => {
          let iosElement;

          beforeEach( function() {
            iosElement = fixture('BasicIosTestFixture');
          });

          it('Should return the correct button from left', () => {
            const buttonPosition = 'left';
            const leftMorphButton = iosElement._getMorphButtonElement(buttonPosition);

            expect(leftMorphButton.getAttribute('color')).to.equal('green');
          });

          it('Should return the correct button from right', () => {
            const buttonPosition = 'right';
            const leftMorphButton = iosElement._getMorphButtonElement(buttonPosition);

            expect(leftMorphButton.getAttribute('color')).to.equal('red');
          });

          it('Should return the correct color attribute of left morph-button', () => {
            const buttonPosition = 'left';
            const morphButtonReturnedColorAttribute = iosElement._getMorphButtonElement(buttonPosition).color;
            const expectedColorAttributeOfMorphButton = 'green';
            
            expect(morphButtonReturnedColorAttribute).to.be.equal(expectedColorAttributeOfMorphButton);
          });

          it('Should return the correct color attribute of right morph-button', () => {
            const buttonPosition = 'right';
            const morphButtonReturnedColorAttribute = iosElement._getMorphButtonElement(buttonPosition).color;
            const expectedColorAttributeOfMorphButton = 'red';

            expect(morphButtonReturnedColorAttribute).to.be.equal(expectedColorAttributeOfMorphButton);
          });



        }); // _getMorphButtonElement()

        describe('_getElementBackgroundColor(element) for IOS platform', () => {
          let element;
          beforeEach(function () {
            element = fixture('BasicIosTestFixture');
          });

          it('Should return the correct background-color for left morph-button', () => {
            const leftMorphButton = element._getMorphButtonElement('left');
            const result = element._getElementBackgroundColor(leftMorphButton);
            const styles = window.getComputedStyle(leftMorphButton);
            const expectedBackgroundColor = 'rgb(76, 217, 100)';

            expect(result).to.equal(expectedBackgroundColor);
          });

          it('Should return the correct background-color for right morph-button', () => {
            const rightMorphButton = element._getMorphButtonElement('right');
            const result = element._getElementBackgroundColor(rightMorphButton);
            const expectedBackgroundColor = 'rgb(255, 59, 48)';

            expect(result).to.equal(expectedBackgroundColor);
          });

        }); // _getElementBackgroundColor(element) for IOS platform

        // BasicAndroidTestFixture
        describe('_getElementBackgroundColor(buttonPosition) for Android platform', () => {
          let element, result;
          let rightMorphButton;

          beforeEach(function (done) {
            element = fixture('BasicAndroidTestFixture');
            rightMorphButton = element._getMorphButtonElement('left');
            // get the background color of morph-button after the 300ms transition timing of translate3d
            setTimeout(function() {
              result = element._getElementBackgroundColor(rightMorphButton);
              done();
            }, 400);
          });

          it('Should return the correct background-color for left morph-button', () => {
            const expectedBackgroundColor = 'rgb(76, 175, 80)';

            expect(result).to.equal(expectedBackgroundColor); 
          });

        }); // _getElementBackgroundColor(buttonPosition) for Android platform

        describe('handleTrack(event) for iOS', () => {
          let element, functionStub;
          let mockEvent;

          beforeEach( () => {
            element = fixture('BasicIosTestFixture');

            stub('morph-swipeout', {
              handleTrack: function () {
                console.log('handleTrack called!');
              }
            });
          });

          it('Should call handleTrack when track event is fired', (done) => {

            flush(function() {
              expect(element.handleTrack.callCount).to.be.equal(0);

              Polymer.Gestures.addListener(element, 'track', e => {
                expect(element.handleTrack.callCount).to.be.equal(1);
                done();
              });

              var event = new CustomEvent('track', {
                detail: {dx: 200}
              });
              
              element.dispatchEvent(event);
            });
            
          });
          
          
        }); // handleTrack(event) for iOS
        
        describe('overswiper for IOS', () => {
          let element;

          beforeEach( () => {
            element = fixture('IosTestFixtureOverswiper');
          });

          describe('Track distance is greater than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {

              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: -601,
                  state: 'end'
                }
              });
            });

            afterEach(function () {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should call _completeOverswipe', (done) => {
              flush(function () {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._completeOverswipe.callCount).to.be.equal(1);
                  done();
                });
                
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);

              });

            });
            
            it('Should call _handleOverswipe', (done) => {
              flush(function () {
                Polymer.Gestures.addListener(element, 'track', e => {
                  flush(function() {
                    expect(element._handleOverswipe.callCount).to.be.equal(1);
                    done();
                  });

                });
                
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });

            });

          }); // Track distance is greater than overswipeTreshold

          //TODO: test that _completeOverswipe and _handleOverswipe are not called when swipe distance is less than overswipeTreshold
          describe('Track distance is less than overswipeTreshold', () => {
            let endEvent;

            beforeEach(() => {

              stub('morph-swipeout', {
                _completeOverswipe: function () {
                  console.log('_completeOverswipe called!');
                }
              });

              stub('morph-swipeout', {
                _handleOverswipe: function () {
                  console.log('_handleOverswipe called!');
                }
              });

              endEvent = new CustomEvent('track', {
                detail: {
                  dx: 201,
                  state: 'end'
                }
              });
            });

            afterEach( () => {
              element._completeOverswipe.restore();
              element._handleOverswipe.restore();
            });

            it('Should NOT call _completeOverswipe', (done) => {
              flush(function() {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._completeOverswipe.called).to.be.false;
                  done();
                });
    
                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });
            });

            it('Should NOT call _handleOverswipe', (done) => {
              flush(function() {
                Polymer.Gestures.addListener(element, 'track', e => {
                  expect(element._handleOverswipe.called).to.be.false;
                  done();
                });

                element._trackInitialTransform = 0;
                element.overswipeTreshold = 500;
                element.dispatchEvent(endEvent);
              });
            });

          }); // Track distance is less than overswipeTreshold


          
        }); // overswiper for IOS

        // let topLeft = MockInteractions.topLeftOfNode(element);
        // let middleOfNode = MockInteractions.middleOfNode(element);

        // MockInteractions.touchstart(element);
        // MockInteractions.track(element, -20, 22, 10);
        // MockInteractions.touchend(element);
        // MockInteractions.tap(element);

      }); // morph-swipeout



    </script>

  </body>
</html>
