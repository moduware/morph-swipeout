<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../morph-element/morph-element.html">
<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../polymer/lib/utils/flattened-nodes-observer.html">

<dom-module id="morph-swipeout">
  <template>
    <style>
      :host {
        --ios-root-container-min-height: 44px;
        --android-root-container-min-height: 48px;
        --swipe-action-after-background-color-right: white;
        --swipe-action-after-background-color-left: white;

        position: relative;
        display: block;
        overflow-x: hidden;
        background-color: var(--back-container-background-color, #fff);
      }

      :host([platform="ios"]) {
        --swipe-action-after-height: var(--ios-root-container-min-height);
      }

      :host([platform="android"]) {
        --swipe-action-after-height: var(--android-root-container-min-height);
      }

      .root-container:not(.no-transition) {
        transition: transform 300ms;
        /* transform: translateX(-40px); */
      }


      :host([platform="ios"]) .root-container {
        min-height: var(--ios-root-container-min-height);
      }

      :host([platform="android"]) .root-container {
        min-height: var(--android-root-container-min-height);
      }

      .left-buttons-container,
      .right-buttons-container {
        position: absolute;
        top: 50%;
      }

      .left-buttons-container {
        left: 0;
        transform: translateY(-50%) translateX(-100%);
      }

      .right-buttons-container {
        right: 0;
        transform: translateY(-50%) translateX(100%);
      }

      :host .left-buttons-container ::slotted([slot="left-buttons"])  morph-button,
      :host .right-buttons-container ::slotted([slot="right-buttons"])  morph-button {
        position: relative;
      }

      :host .left-buttons-container ::slotted([slot="left-buttons"])::after,
      :host .right-buttons-container ::slotted([slot="right-buttons"])::after {
        content: '';
        position: absolute;
        top: 0;
        width: 600%;
        height: var(--swipe-action-after-height);
        
        z-index: -1;
        transform: translate3d(0,0,0);
      }

      :host .right-buttons-container ::slotted([slot="right-buttons"])::after {
        background: var(--swipe-action-after-background-color-right);
        left: 100%;
        margin-left: -1px;
      }

      :host .left-buttons-container ::slotted([slot="left-buttons"])::after {
        background: var(--swipe-action-after-background-color-left, #fff);
        right: 100%;
        margin-right: -1px;
      }

    </style>

    <div class="root-container" id="rootContainer" on-track="handleTrack">
      <div class="left-buttons-container" id="leftButtonsContainer">
        <slot name="left-buttons"></slot>
      </div>
  
      <!-- main content of swipeout goes here -->
      <slot></slot>
  
      <div class="right-buttons-container" id="rightButtonsContainer">
        <slot name="right-buttons"></slot>
      </div>
    </div>

  </template>

  <script>
    /**
     * `morph-swipeout`
     * Component to allow swipeout of content by use that will reveal additional actions that don't take screen space normally
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class MorphSwipeout extends MorphElement(Polymer.GestureEventListeners(Polymer.Element)) {
      static get is() { return 'morph-swipeout'; }
      static get properties() {
        return {
        };
      }

      connectedCallback() {
        super.connectedCallback();
        this._observer = new Polymer.FlattenedNodesObserver(this, (info) => {
          this.info = info;
        });
        this._observer.flush();
        // get the background-color of morph-button and assign to its ::after swipe-action extendsion
        this._getLastRightMorphButtonBackgroundColor();
        this._getLastLeftMorphButtonBackgroundColor();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._observer.disconnect();
      }

      /**
      * Computes for the distance for reveal of right buttons
      * @param {Object} - event The value of the travel of event left or right scroll
      */
      handleTrack(event) {
        // determining our current state
        const rootContainer = this.$.rootContainer;
        let distance = event.detail.dx;
        let normalizedDistance;
        const direction = event.detail.dx > 0 ? 'right' : 'left';

        // console.log(event);
        if(event.detail.state == 'start') {
          // we don't want smooth transitions during user interaction, so removing css smoother
          rootContainer.classList.add('no-transition');
          // determining our buttons container sizes
          this._rightButtonsContainerSize = this.$.rightButtonsContainer.offsetWidth;
          this._leftButtonsContainerSize = this.$.leftButtonsContainer.offsetWidth;
        } else if(event.detail.state == 'end') {
          // after user finished interaction, enabling css smoother back
          rootContainer.classList.remove('no-transition');

          // calculating normilized distance (signless)
          normalizedDistance = this._computeNormalizeDistance(direction, distance);

          // determining our final position by last distance
          // if too small, just cancel
          // if further than half length of button container then reveal buttons
          if(direction == 'left') {
            // when swipe in left direction, reveal right buttons
            distance = this._computeDistanceToRevealRightButtons(normalizedDistance);
          } else {
            // when swipe in right direction, reveal left buttons
            distance = this._computeDistanceToRevealLeftButtons(normalizedDistance);
          }
        }
        
        // On every bit of interaction we are applying it to our element
        if(Math.abs(distance) > 312) return;
        rootContainer.style.transform = `translateX(${distance}px)`;
      }
      
      /**
      * Computes for the signless value or positive value of the number
      * @param {String} - direction The direction of the travel of swipe left or right
      * @param {Number} - distance The value of the travel of event left or right scroll
      */
      _computeNormalizeDistance(direction, distance) {
        if (direction == 'left') return distance *= -1;
      }

      /**
      * Computes for the distance for reveal of right buttons
      * @param {Number} - normalizedDistance The value of the travel of event left or right scroll
      */
      _computeDistanceToRevealRightButtons(normalizedDistance) {
        // when swipe in left direction, reveal right buttons
        if (normalizedDistance < this._rightButtonsContainerSize / 2) {
          return 0;
        } else {
          return this._rightButtonsContainerSize * -1;
        }
      }

      /**
      * Computes for the distance for reveal of left buttons
      * @param {Number} - normalizedDistance The value of the travel of event left or right scroll
      */
      _computeDistanceToRevealLeftButtons(normalizedDistance) {
        // when swipe in left direction, reveal right buttons
        if (normalizedDistance < this._leftButtonsContainerSize / 2) {
          return 0;
        } else {
          return this._leftButtonsContainerSize;
        }
      }

      _getLastRightMorphButtonBackgroundColor() {
        let morphButtonRight = this._getMorphButtonElement('right');
        let rightMorphButtonBackgroundColor = window.getComputedStyle(morphButtonRight).getPropertyValue('background-color');
        
        this.style.setProperty('--swipe-action-after-background-color-right', rightMorphButtonBackgroundColor);
      }

      _getLastLeftMorphButtonBackgroundColor() {
        let morphButtonLeft = this._getMorphButtonElement('left');
        let leftMorphButtonBackgroundColor = window.getComputedStyle(morphButtonLeft).getPropertyValue('background-color');

        this.style.setProperty('--swipe-action-after-background-color-left', leftMorphButtonBackgroundColor);
      }

      _getMorphButtonElement(buttonPosition) {
        let items, lastButton;
        // let elementShadowRoot = this.shadowRoot, observer1, items, lastButton;
        // observer1 = new Polymer.FlattenedNodesObserver(this, function (info) {
        //   items = info;
        // });
        // this._observer.flush();

        let nodes = this.info.addedNodes;

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeName != "#text") {
            var swipeoutChild = nodes[i];

            // get the button container with the correct id
            if (swipeoutChild.getAttribute('slot') == (buttonPosition + '-buttons') ) {
            // check which item matches morph-button id leftLastButton or rightLastButton
              lastButton = swipeoutChild.querySelector('morph-button#' + buttonPosition + 'LastButton');
            }
          }
        }
        return lastButton;
      }

    }

    window.customElements.define(MorphSwipeout.is, MorphSwipeout);
  </script>
</dom-module>
